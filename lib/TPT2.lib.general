; Used to parse multiline expressions as a single AI instruction
#multiline(expr) {lua(return ([[{expr}]]):gsub("\n", ""))}

; A generalization of pos.relative, allows setting position in a rectangular stretchable area
; Is equal to pos.relative(left - x * (left + right - 1.), bottom - x * (bottom + top - 1.), x, y)
; ┌──────┬────────────┬───────┐
; │      │ ↕ top      │       │
; │      ├────────────┤       │
; │ left │←───→╳      │ right │
; │←────→│  x  ↕ y    │←─────→│
; │      ├────────────┤       │
; │      │ ↕ bottom   │       │
; └──────┴────────────┴───────┘
#pos.stretchable(x, y, left, right, bottom, top)={{lua(
  return stretchable("{x}", "{y}", "{left}", "{right}", "{bottom}", "{top}")
)}}

#click.stretchable(x, y, left, right, bottom, top)={
  click({pos.stretchable({x}, {y}, {left}, {right}, {bottom}, {top})})
}

{lua(

  function stretchable(x, y, left, right, bottom, top)

    local function op(operand1, operation, operand2)

      operand1 = tonumber(operand1) or operand1
      operand2 = tonumber(operand2) or operand2

      local expr = string.format("(%s) %s (%s)", operand1, operation, operand2)
      local status, res = pcall(load("return " .. expr))
      if status then
        return res
      end

      if operation == "+" then
        return operand1 == 0.0 and operand2 or operand2 == 0.0 and operand1 or expr
      elseif operation == "*" then
        return (operand1 == 0.0 or operand2 == 0.0) and 0.0
          or operand1 == 1.0 and operand2 or operand2 == 1.0 and operand1 or expr
      end
      return expr

    end

    local vec = {}
  
    vec.x = op(left, "-", op(x, "*", op(left, "+", right)))
    vec.x = op("min(width.d(), (16./9.) * height.d()) * ui.size()", "*", vec.x)
    vec.x = op(vec.x, "+", op("width.d()", "*", x))
  
    vec.y = op(bottom, "-", op(y, "*", op(bottom, "+", top)))
    vec.y = op("min(height.d(), (9./16.) * width.d()) * ui.size()", "*", vec.y)
    vec.y = op(vec.y, "+", op("height.d()", "*", y))
  
    return string.format("vec(%s, %s)", vec.x, vec.y)

  end

  -- Iteratively substitutes %1 with res and %2 with the next argument in the pattern
  -- Reads arguments from the end to the beginning
  function string.nested(pattern, args)
    local argt = string.args(args)
    local res = argt[#argt]
    for i = #argt - 1, 1, -1 do
      res = string.substitute(pattern, res, argt[i])
    end
    return res
  end

  function string.substitute(pattern, ...)

    if select("#", ...) > 9 then
      error("The function supports only up 9 replacement parameters.")
    end

    local res, count = pattern
    for i = 1, select("#", ...) do
      local search1 = string.format("^((%%%%*)%%2)(%%%%%u)(.*)", i)
      local search2 = string.format("(.-[^%%%%](%%%%*)%%2)(%%%%%u)(.*)", i)
      local repl = string.format("%%1%s%%4", select(i, ...))
      res, count = res:gsub(search1, repl, 1):gsub(search2, repl, 1)
      while count > 0 do
        res, count = res:gsub(search2, repl, 1)
      end
    end

    return res

  end

  function string.args(args)

    local res = {}
    local first, last = 1, args:find([[([,'"])]], 1)

    while last do
      local symbol = args:sub(last, last)
      if symbol ~= "," then
        last = args:find(symbol, last + 1)
      else
        table.insert(res, args:sub(first, last - 1):match("^%s*(.-)%s*$"))
        first = last + 1
      end
      last = args:find([[([,'"])]], last + 1)
    end
    table.insert(res, args:sub(first):match("^%s*(.-)%s*$"))

    return res

  end

)}
